const {Maze, MazeImpossibleToSolveError} = require('./challenge_29')

describe('Best way to navigate',
    () => it.each([
        [
            [
                ['#', ' ', ' ', ' ', ' ', '#', ' '],
                [' ', 'S', ' ', ' ', '#', ' ', ' '],
                [' ', ' ', '#', ' ', ' ', '#', ' '],
                [' ', '#', ' ', ' ', ' ', '#', 'E'],
                [' ', ' ', ' ', ' ', ' ', ' ', ' '],
                ['#', '#', ' ', ' ', '#', ' ', ' '],
                [' ', ' ', ' ', ' ', ' ', ' ', ' ']
            ],
            ['(1, 1)', '(1, 2)', '(1, 3)', '(2, 3)', '(3, 3)', '(4, 3)', '(4, 4)', '(4, 5)', '(4, 6)', '(3, 6)']
        ],
        [
            [
                ['E', ' ', ' ', ' '],
                ['#', ' ', '#', ' '],
                [' ', ' ', ' ', ' '],
                [' ', '#', '#', ' '],
                [' ', ' ', '#', ' '],
                ['#', ' ', '#', ' '],
                [' ', ' ', '#', ' '],
                [' ', ' ', ' ', 'S']
            ],
            ['(7, 3)', '(6, 3)', '(5, 3)', '(4, 3)', '(3, 3)', '(2, 3)', '(1, 3)', '(0, 3)', '(0, 2)', '(0, 1)', '(0, 0)']
        ],
        [
            [
                [' ', ' ', ' ', ' ', ' '],
                [' ', ' ', 'S', ' ', ' '],
                [' ', '#', '#', ' ', ' '],
                [' ', '#', 'E', '#', ' '],
                [' ', '#', ' ', '#', ' '],
                [' ', ' ', ' ', '#', ' '],
                [' ', ' ', ' ', ' ', ' ']
            ],
            ['(1, 2)', '(1, 1)', '(1, 0)', '(2, 0)', '(3, 0)', '(4, 0)', '(5, 0)', '(5, 1)', '(5, 2)', '(4, 2)', '(3, 2)']
        ],
        [
            [
                [' ', '#', '#', 'S', '#', '#', '#'],
                ['#', '#', ' ', ' ', ' ', ' ', '#'],
                ['#', ' ', ' ', '#', '#', ' ', '#'],
                ['#', ' ', ' ', ' ', ' ', ' ', '#'],
                ['#', ' ', '#', ' ', '#', ' ', '#'],
                ['#', ' ', ' ', ' ', '#', ' ', '#'],
                ['#', '#', ' ', '#', ' ', ' ', '#'],
                ['#', '#', ' ', ' ', ' ', '#', '#'],
                ['#', ' ', ' ', ' ', '#', ' ', '#'],
                ['#', ' ', '#', ' ', ' ', '#', '#'],
                ['#', ' ', ' ', '#', '#', '#', '#'],
                ['#', ' ', ' ', ' ', ' ', ' ', '#'],
                ['#', '#', ' ', ' ', '#', ' ', '#'],
                ['#', '#', '#', '#', '#', 'E', '#']
            ],
            ['(0, 3)', '(1, 3)', '(1, 2)', '(2, 2)', '(2, 1)', '(3, 1)', '(4, 1)', '(5, 1)', '(5, 2)', '(6, 2)', '(7, 2)', '(8, 2)', '(8, 1)', '(9, 1)', 
                '(10, 1)', '(11, 1)', '(11, 2)', '(11, 3)', '(11, 4)', '(11, 5)', '(12, 5)', '(13, 5)']
        ]
    ])
        ('when map is %s then a route is %s', 
        (dungeonMap, expected) => {
            const maze = new Maze(dungeonMap)
            expect(maze.breadthFirstSearch()).toEqual(expected)
        }),

    test('when maze is impossible to reach end then throw errot', () =>{
        const dungeonMap = [
            ['S', ' ', ' ', ' ', ' '],
            [' ', ' ', ' ', '#', '#'],
            [' ', ' ', ' ', '#', 'E'],
            [' ', ' ', ' ', '#', '#'],
            [' ', ' ', ' ', ' ', ' ']
        ]
        const maze = new Maze(dungeonMap)
        expect(() => maze.breadthFirstSearch()).toThrowError(MazeImpossibleToSolveError)
    })
    
    )